"""
Templates for app scaffold generation.

Uses simple string formatting (not Jinja2) to avoid dependencies.
Placeholders use {name} format.
"""

# =============================================================================
# main.py template
# =============================================================================

MAIN_PY = '''"""
{description}

Generated by appctl from app.manifest.yaml
"""

from pathlib import Path
from typing import Tuple

from backend.app_kernel import (
    create_service,
    ServiceConfig,
    get_logger,
)

from .config import get_settings
from .db_schema import init_schema
{tasks_import}
{routes_import}


# =============================================================================
# Health Checks
# =============================================================================

async def check_database() -> Tuple[bool, str]:
    """Health check for database connection."""
    try:
        from backend.app_kernel.db import get_db_manager
        db_manager = get_db_manager()
        async with db_manager as conn:
            await conn.execute("SELECT 1", ())
        return True, "database connected"
    except Exception as e:
        return False, f"database error: {{e}}"

{redis_health_check}

# =============================================================================
# Lifecycle
# =============================================================================

async def on_startup():
    """Initialize app-specific dependencies."""
    logger = get_logger()
    logger.info("{name} started")


async def on_shutdown():
    """Cleanup on shutdown."""
    get_logger().info("{name} shutting down")


# =============================================================================
# Config Builder
# =============================================================================

def _build_config() -> ServiceConfig:
    """Build ServiceConfig from settings."""
    settings = get_settings()
    return ServiceConfig(
        # Auth
        jwt_secret=settings.jwt_secret,
        jwt_expiry_hours=settings.jwt_expiry_hours,
        auth_enabled=settings.auth_enabled,
        allow_self_signup=settings.allow_self_signup,
        
        # Redis
        redis_url=settings.redis_url,
        redis_key_prefix="{redis_prefix}",
        
        # Database
        database_name=settings.database_name,
        database_type=settings.database_type,
        database_host=settings.database_host,
        database_port=settings.database_port,
        database_user=settings.database_user,
        database_password=settings.database_password,
        
        # CORS
        cors_origins=list(settings.cors_origins),
        cors_credentials={cors_credentials},
        
        # Debug
        debug=settings.debug,
        log_level="DEBUG" if settings.debug else "INFO",
    )


# =============================================================================
# Create App
# =============================================================================

def create_app():
    """Create the FastAPI application."""
    settings = get_settings()
    {tasks_dict}
    
    app = create_service(
        name="{name}",
        version=settings.version,
        description=__doc__,
        
        # Routes
        routers=[
{routers_list}
        ],
        
        # Background tasks
        {tasks_arg}
        
        # Configuration
        config=_build_config(),
        
        # Database schema
        schema_init=init_schema,
        
        # Lifecycle
        on_startup=on_startup,
        on_shutdown=on_shutdown,
        
        # Health checks
        health_checks=[check_database{redis_health_arg}],
    )
    
    return app


# Create app instance
app = create_app()


if __name__ == "__main__":
    import uvicorn
    settings = get_settings()
    uvicorn.run("{name}.main:app", host=settings.host, port=settings.port, reload=settings.debug)
'''


# =============================================================================
# config.py template
# =============================================================================

CONFIG_PY = '''"""
Service configuration using environment variables.

Generated by appctl from app.manifest.yaml
"""

import os
from dataclasses import dataclass
from typing import Optional, Tuple
from functools import lru_cache


def _env(key: str, default: str = None) -> Optional[str]:
    """Get env var with {name_upper}_ prefix."""
    return os.environ.get(f"{name_upper}_{{key}}", os.environ.get(key, default))


def _env_bool(key: str, default: bool = False) -> bool:
    """Get boolean env var."""
    val = _env(key)
    if val is None:
        return default
    return val.lower() in ("true", "1", "yes")


def _env_int(key: str, default: int) -> int:
    """Get integer env var."""
    val = _env(key)
    return int(val) if val else default


@dataclass(frozen=True)
class Settings:
    """Application settings - frozen after creation."""
    # Service
    name: str
    version: str
    debug: bool
    host: str
    port: int
    
    # Database
    database_type: str
    database_name: str
    database_host: str
    database_port: Optional[int]
    database_user: Optional[str]
    database_password: Optional[str]
    
    # Redis
    redis_url: Optional[str]
    
    # Auth
    auth_enabled: bool
    allow_self_signup: bool
    jwt_secret: str
    jwt_expiry_hours: int
    
    # CORS
    cors_origins: Tuple[str, ...]


def _create_settings() -> Settings:
    """Create settings from environment."""
    cors = _env("CORS_ORIGINS", "{cors_origins_default}")
    cors_tuple = tuple(cors.split(",")) if cors else ("*",)
    
    return Settings(
        # Service
        name="{name}",
        version=_env("VERSION", "{version}"),
        debug=_env_bool("{debug_env}", False),
        host=_env("HOST", "{host}"),
        port=_env_int("PORT", {port}),
        
        # Database
        database_type=_env("DATABASE_TYPE", "{db_type}"),
        database_name=_env("DATABASE_NAME", "{db_name}"),
        database_host=_env("DATABASE_HOST", "{db_host}"),
        database_port=_env_int("DATABASE_PORT", {db_port}),
        database_user=_env("DATABASE_USER", {db_user}),
        database_password=_env("{db_password_env}"),
        
        # Redis
        redis_url=_env("{redis_url_env}"),
        
        # Auth
        auth_enabled=_env_bool("AUTH_ENABLED", {auth_enabled}),
        allow_self_signup=_env_bool("ALLOW_SELF_SIGNUP", {allow_signup}),
        jwt_secret=_env("{jwt_secret_env}", "change-me-in-production"),
        jwt_expiry_hours=_env_int("JWT_EXPIRY_HOURS", {jwt_expiry}),
        
        # CORS
        cors_origins=cors_tuple,
    )


@lru_cache()
def get_settings() -> Settings:
    """Get settings instance (cached, frozen)."""
    return _create_settings()
'''


# =============================================================================
# db_schema.py template
# =============================================================================

DB_SCHEMA_PY = '''"""
Database schema for {name}.

Generated by appctl from app.manifest.yaml

Tables:
{table_list}
"""

from typing import Any


async def init_schema(db: Any) -> None:
    """
    Initialize database schema.
    
    Called by kernel after database connection established.
    """
{schema_statements}
'''


# =============================================================================
# tasks.py template
# =============================================================================

TASKS_PY = '''"""
Background task handlers for {name}.

Generated by appctl from app.manifest.yaml

Register these in main.py via:
    tasks={{name: handler for name, handler in TASKS.items()}}
"""

from typing import Dict, Any

from backend.app_kernel import get_logger, get_metrics
from backend.app_kernel.jobs import JobContext
from backend.app_kernel.db import get_db_session


logger = get_logger()
metrics = get_metrics()


{task_handlers}

# Task registry - maps task names to handlers
TASKS = {{
{task_registry}
}}
'''


# =============================================================================
# Entity route template
# =============================================================================

ENTITY_ROUTE_PY = '''"""
CRUD routes for {entity_name}.

Generated by appctl from app.manifest.yaml
"""

from typing import List, Optional
from fastapi import APIRouter, Depends, HTTPException, Query

from backend.app_kernel.db import db_session_dependency, AsyncConnection
from backend.app_kernel.auth import get_current_user, UserIdentity
{workspace_import}

from ..schemas import {schema_classes}


router = APIRouter(prefix="/{entity_name_plural}", tags=["{entity_name_plural}"])


@router.post("", response_model={entity_name_pascal}Response, status_code=201)
async def create_{entity_name}(
    data: {entity_name_pascal}Create,
    db: AsyncConnection = Depends(db_session_dependency),
    user: UserIdentity = Depends(get_current_user),
{workspace_param}
):
    """Create a new {entity_name}."""
    import uuid
    from datetime import datetime, timezone
    
    entity = {{
        "id": str(uuid.uuid4()),
        **data.model_dump(),
{workspace_field}
        "created_at": datetime.now(timezone.utc).isoformat(),
        "updated_at": datetime.now(timezone.utc).isoformat(),
    }}
    
    await db.save_entity("{entity_name_plural}", entity)
    return entity


@router.get("", response_model=List[{entity_name_pascal}Response])
async def list_{entity_name_plural}(
    db: AsyncConnection = Depends(db_session_dependency),
    user: UserIdentity = Depends(get_current_user),
{workspace_param}
    limit: int = Query(default=100, le=1000),
    offset: int = Query(default=0, ge=0),
):
    """List {entity_name_plural}."""
    filters = {{{workspace_filter}{deleted_filter}}}
    entities = await db.find_entities("{entity_name_plural}", filters, limit=limit, offset=offset)
    return entities


@router.get("/{{id}}", response_model={entity_name_pascal}Response)
async def get_{entity_name}(
    id: str,
    db: AsyncConnection = Depends(db_session_dependency),
    user: UserIdentity = Depends(get_current_user),
{workspace_param}
):
    """Get a {entity_name} by ID."""
    entity = await db.get_entity("{entity_name_plural}", id)
    if not entity:
        raise HTTPException(status_code=404, detail="{entity_name_pascal} not found")
{workspace_check}
    return entity


@router.put("/{{id}}", response_model={entity_name_pascal}Response)
async def update_{entity_name}(
    id: str,
    data: {entity_name_pascal}Update,
    db: AsyncConnection = Depends(db_session_dependency),
    user: UserIdentity = Depends(get_current_user),
{workspace_param}
):
    """Update a {entity_name}."""
    from datetime import datetime, timezone
    
    entity = await db.get_entity("{entity_name_plural}", id)
    if not entity:
        raise HTTPException(status_code=404, detail="{entity_name_pascal} not found")
{workspace_check}
    
    updated = {{
        **entity,
        **data.model_dump(exclude_unset=True),
        "updated_at": datetime.now(timezone.utc).isoformat(),
    }}
    
    await db.save_entity("{entity_name_plural}", updated)
    return updated


@router.delete("/{{id}}", status_code=204)
async def delete_{entity_name}(
    id: str,
    db: AsyncConnection = Depends(db_session_dependency),
    user: UserIdentity = Depends(get_current_user),
{workspace_param}
):
    """Delete a {entity_name}."""
{delete_impl}
'''


# =============================================================================
# schemas.py template
# =============================================================================

SCHEMAS_PY = '''"""
Pydantic schemas for {name}.

Generated by appctl from app.manifest.yaml
"""

from typing import Optional, List, Any
from datetime import datetime
from pydantic import BaseModel, Field


{entity_schemas}
'''


# =============================================================================
# routes/__init__.py template
# =============================================================================

ROUTES_INIT_PY = '''"""
Route modules for {name}.

Generated by appctl from app.manifest.yaml
"""

{route_imports}

__all__ = [
{route_exports}
]
'''


# =============================================================================
# __init__.py template
# =============================================================================

INIT_PY = '''"""
{name} - {description}

Generated by appctl from app.manifest.yaml
"""

__version__ = "{version}"
'''


# =============================================================================
# Dockerfile template
# =============================================================================

DOCKERFILE = '''# Dockerfile for {name}
# Generated by appctl from app.manifest.yaml

FROM python:3.11-slim

WORKDIR /app

# Install dependencies
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# Copy application
COPY . .

# Create data directory
RUN mkdir -p /app/data

# Environment
ENV PYTHONPATH=/app
ENV HOST=0.0.0.0
ENV PORT={port}

EXPOSE {port}

CMD ["python", "-m", "uvicorn", "{name}.main:app", "--host", "0.0.0.0", "--port", "{port}"]
'''


# =============================================================================
# docker-compose.yml template
# =============================================================================

DOCKER_COMPOSE = '''# Docker Compose for {name}
# Generated by appctl from app.manifest.yaml

version: "3.8"

services:
  {name}:
    build: .
    ports:
      - "{port}:{port}"
    environment:
      - {jwt_secret_env}=${{JWT_SECRET:-dev-secret-change-me}}
      - DATABASE_TYPE={db_type}
      - DATABASE_NAME={db_name_compose}
{redis_env}
{db_env}
    volumes:
      - ./data:/app/data
{depends_on}
{redis_service}
{db_service}
'''


# =============================================================================
# requirements.txt template
# =============================================================================

REQUIREMENTS_TXT = '''# Requirements for {name}
# Generated by appctl from app.manifest.yaml

fastapi>=0.109.0
uvicorn>=0.27.0
pydantic>=2.5.0
python-dotenv>=1.0.0

# Database (adjust based on your database type)
{db_requirements}

# Redis (if enabled)
{redis_requirements}
'''


# =============================================================================
# .env.example template
# =============================================================================

ENV_EXAMPLE = '''# Environment variables for {name}
# Generated by appctl from app.manifest.yaml
# Copy to .env and adjust values

# Service
{name_upper}_DEBUG=false
{name_upper}_HOST={host}
{name_upper}_PORT={port}

# Database
{name_upper}_DATABASE_TYPE={db_type}
{name_upper}_DATABASE_NAME={db_name}
{db_env_vars}

# Auth
{name_upper}_{jwt_secret_env}=change-me-in-production
{name_upper}_AUTH_ENABLED={auth_enabled}
{name_upper}_ALLOW_SELF_SIGNUP={allow_signup}

# Redis
{redis_env_vars}

# CORS
{name_upper}_CORS_ORIGINS={cors_origins}
'''


# =============================================================================
# app.manifest.yaml template (for reference)
# =============================================================================

MANIFEST_YAML = '''# App Manifest for {name}
# This file defines your application structure
# Run: appctl new --from-manifest app.manifest.yaml

name: {name}
version: {version}
description: "{description}"

database:
  type: {db_type}
  name: {db_name}

redis:
  enabled: {redis_enabled}

auth:
  enabled: {auth_enabled}
  allow_signup: {allow_signup}

cors:
  origins:
{cors_origins_yaml}

tasks:
{tasks_yaml}

entities:
{entities_yaml}
'''
